from _typeshed import Incomplete
from cuda.core.experimental._device import Device as Device
from cuda.core.experimental._module import ObjectCode as ObjectCode
from cuda.core.experimental._utils.clear_error_support import assert_type as assert_type
from cuda.core.experimental._utils.cuda_utils import check_or_create_options as check_or_create_options, driver as driver, handle_return as handle_return, is_sequence as is_sequence
from dataclasses import dataclass

@dataclass
class LinkerOptions:
    name: str | None = ...
    arch: str | None = ...
    max_register_count: int | None = ...
    time: bool | None = ...
    verbose: bool | None = ...
    link_time_optimization: bool | None = ...
    ptx: bool | None = ...
    optimization_level: int | None = ...
    debug: bool | None = ...
    lineinfo: bool | None = ...
    ftz: bool | None = ...
    prec_div: bool | None = ...
    prec_sqrt: bool | None = ...
    fma: bool | None = ...
    kernels_used: str | tuple[str] | list[str] | None = ...
    variables_used: str | tuple[str] | list[str] | None = ...
    optimize_unused_variables: bool | None = ...
    ptxas_options: str | tuple[str] | list[str] | None = ...
    split_compile: int | None = ...
    split_compile_extended: int | None = ...
    no_cache: bool | None = ...
    formatted_options = ...
    def __post_init__(self) -> None: ...
nvJitLinkHandleT = int
LinkerHandleT: Incomplete

class Linker:
    class _MembersNeededForFinalize:
        handle: Incomplete
        use_nvjitlink: Incomplete
        const_char_keep_alive: Incomplete
        def __init__(self, program_obj, handle, use_nvjitlink) -> None: ...
        def close(self) -> None: ...
    def __init__(self, *object_codes: ObjectCode, options: LinkerOptions = None) -> None: ...
    def link(self, target_type) -> ObjectCode: ...
    def get_error_log(self) -> str: ...
    def get_info_log(self) -> str: ...
    @property
    def handle(self) -> LinkerHandleT: ...
    @property
    def backend(self) -> str: ...
    def close(self) -> None: ...
